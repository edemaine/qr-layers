solid-js import {createMemo, createSignal, For, Show}
qrcode import qrcode, {type BitMatrix}
./layers.civet import {computeLayering, computeOutlines, type Layering}
./matrix.civet import {bitMatrixToMatrix, Matrix, type MatrixType}

export function DisplayMatrix(props: {matrix: MatrixType?, color?: number, margin: number})
  onColor := createMemo => props.color is not 0 ? "black" : "white"
  offColor := createMemo => props.color is not 0 ? "white" : "black"
  width := createMemo => props.matrix!.nx + 2 * props.margin
  height := createMemo => props.matrix!.ny + 2 * props.margin
  <Show when=props.matrix keyed>(matrix) =>
    <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
      <rect x=-props.margin y=-props.margin {width(), height()} fill={props.color? ? onColor() : "white"}>
      <For each=[0...matrix.nx]>(x) =>
        <For each=[0...matrix.ny]>(y) =>
          <rect {x,y} width=1 height=1 fill={matrix.get(x, y) ? onColor() : offColor()} stroke={matrix.get(x, y) ? onColor() : offColor()} stroke-width={0.05}>

export function DisplayOutlines(props: {nx: number, ny: number, outlines: [number, number][][]?, fill?: number, stroke?: number, strokeColors?: string[], margin: number})
  onColor := createMemo => props.fill is not 0 ? "white" : "black"
  offColor := createMemo => props.fill is not 0 ? "black" : "white"
  width := createMemo => props.nx + 2 * props.margin
  height := createMemo => props.ny + 2 * props.margin
  <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
    <rect x=-props.margin y=-props.margin {width(), height()} fill={props.stroke ? "white" : offColor()}>
    <For each=props.outlines>(polygon, index) =>
      <polygon points={polygon.map([x, y] => `${x},${y}`).join " "} fill={props.stroke ? "none" : onColor()} stroke={props.stroke ? props.strokeColors?[index()] ?? "black" : "none"} stroke-width={props.stroke}>

export function App()
  [margin, setMargin] := createSignal<number> 1
  [stroke, setStroke] := createSignal<number> 0.2
  [qrMatrix, setQrMatrix] := createSignal<Matrix?>()
  [layers, setLayers] := createSignal<Layering?>()
  [outlines, setOutlines] := createSignal<[number, number][][][]?>()

  let textRef: HTMLInputElement, qualityRef: HTMLSelectElement
  function onInput(): void
    text := textRef.value
    unless text
      setQrMatrix undefined
      setLayers undefined
      return
    qr := qrcode.create text, errorCorrectionLevel: qualityRef.value as "L" | "M" | "Q" | "H"
    setQrMatrix bitMatrixToMatrix qr.modules
    setLayers computeLayering qrMatrix()!
    setOutlines
      for level of [1<=..layers()!.levels]
        computeOutlines
          layers()!.layer.map (value) => Number value <= level

  let downloadRef: HTMLAnchorElement
  function download(className: string): void
    for each svg, i of document.querySelectorAll `.${className} svg`
      text := `<?xml version="1.0" encoding="utf-8"?>\n` + svg.outerHTML
      .replace /<svg/, `<svg xmlns="http://www.w3.org/2000/svg" version="1.1"`
      url := URL.createObjectURL new Blob [text], type: 'image/svg+xml'
      downloadRef.href = url
      downloadRef.download = `qr-${className}${i+1}.svg`
      downloadRef.click() // synchronous
      downloadRef.href = ''
      URL.revokeObjectURL url

  <form onSubmit={(e) => e.preventDefault()}>
    <input {onInput} placeholder="Message for QR code" style="width: 500px" ref=textRef!>
    <select {onInput} ref=qualityRef!>
      <option value="L">Low (~7%)
      <option value="M" selected>Medium (~15%)
      <option value="Q">Quartile (~25%)
      <option value="H">High (~30%)
    <label>Margin: 
      <input type="number" value=margin() min=0 step="any" onInput=
        (e) => setMargin e.currentTarget.valueAsNumber
      >
  <Show when=qrMatrix()>
    <h2>QR Code
    <DisplayMatrix matrix=qrMatrix() {margin()}>
  <Show when=false>
    <h2>{layers()?.levels} Layers as pixels
    <For each=[1<=..layers()?.levels ?? 0]>(level) =>
      <DisplayMatrix matrix={layers()?.layer.map (value) => Number value <= level} color=layers()?.colorMap.get(level) {margin()}>
  <Show when=outlines()>
    <h2>{layers()?.levels} Layers
    <.layers>
      <For each=outlines()>(outlines, level) =>
        <DisplayOutlines {outlines, qrMatrix()!.nx, qrMatrix()!.ny} fill=layers()!.colorMap.get(level()+1)! {margin()}>
        <!--<DisplayOutlines {outlines, qrMatrix()!.{nx,ny}} color=layers()!.colorMap.get(level)! {margin()}>-->
    <button onClick={(e) => download 'layers'}>Download SVGs
    <a ref=downloadRef! style="display: none">

    <h2>{layers()?.levels} Outlines â€” 
      <input type="number" min=0 value=stroke() onChange=
        (e) => setStroke e.currentTarget.valueAsNumber
      >
    <.outlines>
      <For each=outlines()>(outlines) =>
        <DisplayOutlines {outlines, qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()}>
    <div>
      <DisplayOutlines outlines=outlines()!.flat() {qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()}>
      <DisplayOutlines outlines=outlines()!.flat() {qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()} strokeColors=
        do
          colors := ["black", "purple", "red", "orange"]
          strokes := []
          for outline, i of outlines()!
            color := colors[i%]
            for polygon of outline
              strokes.push color
          strokes
      >

    <Show when=false>
      <h2>{layers()?.levels} Levels
      <For each=[1<=..layers()?.levels ?? 0]>(level) =>
        <DisplayMatrix matrix={layers()?.layer.map (value) => Number value is level} {margin()}>
