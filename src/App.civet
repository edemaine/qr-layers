solid-js import {batch, createEffect, createMemo, createSignal, onMount, Index, For, Show}
solid-js/store import {createStore}
qrcode import qrcode, {type BitMatrix}
./layers.civet import {computeLayering, computeOutlines, type Layering}
./matrix.civet import {bitMatrixToMatrix, Matrix, type MatrixType}

export function DisplayMatrix(props: {matrix: MatrixType?, color?: number, margin: number})
  onColor := createMemo => props.color is not 0 ? "black" : "white"
  offColor := createMemo => props.color is not 0 ? "white" : "black"
  width := createMemo => props.matrix!.nx + 2 * props.margin
  height := createMemo => props.matrix!.ny + 2 * props.margin
  <Show when=props.matrix keyed>(matrix) =>
    <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
      <rect x=-props.margin y=-props.margin {width(), height()} fill={props.color? ? onColor() : "white"}>
      <For each=[0...matrix.nx]>(x) =>
        <For each=[0...matrix.ny]>(y) =>
          <rect {x,y} width=1 height=1 fill={matrix.get(x, y) ? onColor() : offColor()} stroke={matrix.get(x, y) ? onColor() : offColor()} stroke-width={0.05}>

export function DisplayOutlines(props: {nx: number, ny: number, outlines: [number, number][][]?, fill?: number, stroke?: number, shadow?: boolean, fillColors?: string[], strokeColors?: string[], background?: string, margin: number})
  onColor := createMemo => props.fill is not 0 ? "white" : "black"
  offColor := createMemo => props.fill is not 0 ? "black" : "white"
  width := createMemo => props.nx + 2 * props.margin
  height := createMemo => props.ny + 2 * props.margin
  <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
    <rect x=-props.margin y=-props.margin {width(), height()} fill={props.background ?? (props.stroke ? "white" : offColor())}>
    <For each=props.outlines>(polygon, index) =>
      <polygon points={polygon.map([x, y] => `${x},${y}`).join " "}
      fill={props.shadow ? offColor() : props.stroke ? "none" : props.fillColors ? props.fillColors[index()] : onColor()}
      stroke={props.stroke ? props.strokeColors?[index()] ?? "black" : "none"}
      stroke-width={props.stroke}
      style={if props.shadow then `filter: drop-shadow(0 0 0.1px ${onColor()})`}>

defaults :=
  text: ''
  quality: 'M'
  margin: 1
  stroke: 0.2
as const

export function App()
  [text, setText] := createSignal<string> defaults.text
  [quality, setQuality] := createSignal<"L" | "M" | "Q" | "H"> defaults.quality
  [margin, setMargin] := createSignal<number> defaults.margin
  [stroke, setStroke] := createSignal<number> defaults.stroke
  [qrMatrix, setQrMatrix] := createSignal<Matrix?>()
  [layers, setLayers] := createSignal<Layering?>()
  [outlines, setOutlines] := createSignal<[number, number][][][]?>()
  [stackColors, setStackColors] := createStore<string[]>([])
  function getStackColor(i: number): string
    stackColors[i] ?? (i % 2 ? '#000000' : '#ffffff')

  let qualityRef: HTMLSelectElement
  createEffect =>
    unless text()
      batch =>
        setQrMatrix undefined
        setLayers undefined
        setOutlines undefined
      return
    qr := qrcode.create text(), errorCorrectionLevel: quality()
    batch =>
      setQrMatrix bitMatrixToMatrix qr.modules
      // Force initial color of 0 (white) to guarantee white margin
      setLayers computeLayering qrMatrix()!, 0
      setOutlines
        for level of [1<=..layers()!.levels]
          computeOutlines
            layers()!.layer.map (value) => Number value <= level

  function loadURL: void
    batch =>
      params := new URLSearchParams window.location.search
      setText params.get('text') ?? defaults.text
      if params.get('quality') is in ['L', 'M', 'Q', 'H'] as (string??)[]
        setQuality params.get('quality') as 'L' | 'M' | 'Q' | 'H'
      else
        setQuality defaults.quality
      m .= parseInt params.get('margin')!, 10
      setMargin isNaN(m) ? defaults.margin : m
      s := parseFloat params.get('stroke')!
      setStroke isNaN(s) ? defaults.stroke : s
  onMount => loadURL()
  window.addEventListener 'popstate', loadURL

  createEffect =>
    // Update URL
    search .= ''
    search += `&text=${encodeURIComponent text()}` if text() is not defaults.text
    search += `&quality=${quality()}` if quality() is not defaults.quality
    search += `&margin=${margin()}` if margin() is not defaults.margin
    search += `&stroke=${stroke()}` if stroke() is not defaults.stroke
    search = `?${search[1..]}` if search
    unless search is window.location.search
      history.pushState null, 'qr', `${window.location.pathname}${search}`

  let downloadRef: HTMLAnchorElement
  function download(className: string): void
    for each svg, i of document.querySelectorAll `.${className} svg`
      text := `<?xml version="1.0" encoding="utf-8"?>\n` + svg.outerHTML
      .replace /<svg/, `<svg xmlns="http://www.w3.org/2000/svg" version="1.1"`
      url := URL.createObjectURL new Blob [text], type: 'image/svg+xml'
      downloadRef.href = url
      downloadRef.download = `qr-${className}${i+1}.svg`
      downloadRef.click() // synchronous
      downloadRef.href = ''
      URL.revokeObjectURL url

  <form onSubmit={(e) => e.preventDefault()}>
    <input placeholder="Message for QR code" style="width: 500px" value=text()
    onInput=
      (e) => setText e.currentTarget.value
    >
    <select value=quality() onInput=
      (e) => setQuality e.currentTarget.value as "L" | "M" | "Q" | "H"
    >
      <option value="L">Low (~7%)
      <option value="M">Medium (~15%)
      <option value="Q">Quartile (~25%)
      <option value="H">High (~30%)
    <label>Margin: 
      <input type="number" value=margin() min=0 step="any" onInput=
        (e) => setMargin e.currentTarget.valueAsNumber
      >
  <Show when=qrMatrix()>
    <h2>QR Code
    <DisplayMatrix matrix=qrMatrix() {margin()}>
  <Show when=false>
    <h2>{layers()?.levels} Layers as pixels
    <For each=[1<=..layers()?.levels ?? 0]>(level) =>
      <DisplayMatrix matrix={layers()?.layer.map (value) => Number value <= level} color=layers()?.colorMap.get(level) {margin()}>
  <Show when=outlines()>
    <h2>{layers()?.levels} Layers
    <.layers>
      <For each=outlines()>(outlines, level) =>
        <DisplayOutlines {outlines, qrMatrix()!.nx, qrMatrix()!.ny} fill=layers()!.colorMap.get(level()+1)! {margin()}>
        <!--<DisplayOutlines {outlines, qrMatrix()!.{nx,ny}} color=layers()!.colorMap.get(level)! {margin()}>-->
    <button onClick={(e) => download 'layers'}>Download SVGs
    <a ref=downloadRef! style="display: none">

    <h2>Colored Stack
    <form>
      <Index each=outlines()!>
        (o, i) =>
          <input type="color"
            value=
              getStackColor i
            onInput=
              (e) => setStackColors i, e.currentTarget.value
          >
    <div>
      <DisplayOutlines outlines=outlines()!.flat()
        fillColors=
          for layer, i of outlines()!
            for j of [1..layer#]
              getStackColor i+1
              /* Regular QR:
              if layers()!.colorMap.get(i+1)
                'white'
              else
                'black'
              */
          .flat()
        background=getStackColor(0)
        fill=0
        {qrMatrix()!.nx, qrMatrix()!.ny}
        {margin()}>

    <h2>Same-Color Stacks
    <div>
      <For each=[0,1]>(color) =>
        <DisplayOutlines outlines=
          for outline, i of outlines()! when layers()!.colorMap.get(i+1) is color
            outline
          .flat()
        {qrMatrix()!.nx, qrMatrix()!.ny} fill=color shadow {margin()}>

    <h2>{layers()?.levels} Outlines â€”
      <input type="number" min=0 value=stroke() step="any" onChange=
        (e) => setStroke e.currentTarget.valueAsNumber
      >
    <.outlines>
      <For each=outlines()>(outlines) =>
        <DisplayOutlines {outlines, qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()}>
    <div>
      <DisplayOutlines outlines=outlines()!.flat() {qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()}>
      <DisplayOutlines outlines=outlines()!.flat() {qrMatrix()!.nx, qrMatrix()!.ny} {margin(), stroke()} strokeColors=
        do
          colors := ["black", "#a00"]
          strokes := []
          for outline, i of outlines()!
            color := colors[i%]
            for polygon of outline
              strokes.push color
          strokes
      >

    <Show when=false>
      <h2>{layers()?.levels} Levels
      <For each=[1<=..layers()?.levels ?? 0]>(level) =>
        <DisplayMatrix matrix={layers()?.layer.map (value) => Number value is level} {margin()}>
