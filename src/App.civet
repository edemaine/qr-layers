solid-js import {createMemo, createSignal, For, Show}
qrcode import qrcode, {type BitMatrix}
./layers.civet import {layering, outlines, type Layering}
./matrix.civet import {bitMatrixToMatrix, Matrix, type MatrixType}

export function DisplayMatrix(props: {matrix: MatrixType?, color?: number, margin: number})
  onColor := createMemo => props.color is not 0 ? "black" : "white"
  offColor := createMemo => props.color is not 0 ? "white" : "black"
  width := createMemo => props.matrix!.nx + 2 * props.margin
  height := createMemo => props.matrix!.ny + 2 * props.margin
  <Show when=props.matrix keyed>(matrix) =>
    <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
      <rect x=-props.margin y=-props.margin {width(), height()} fill={props.color? ? onColor() : "white"}>
      <For each=[0...matrix.nx]>(x) =>
        <For each=[0...matrix.ny]>(y) =>
          <rect {x,y} width=1 height=1 fill={matrix.get(x, y) ? onColor() : offColor()} stroke={matrix.get(x, y) ? onColor() : offColor()} stroke-width={0.05}>

export function DisplayOutlines(props: {matrix: MatrixType?, color: number, margin: number})
  onColor := createMemo => props.color is not 0 ? "white" : "black"
  offColor := createMemo => props.color is not 0 ? "black" : "white"
  width := createMemo => props.matrix!.nx + 2 * props.margin
  height := createMemo => props.matrix!.ny + 2 * props.margin
  <Show when=
    outlines props.matrix if props.matrix?
  keyed>(polygons) =>
    <svg viewBox=`${-props.margin} ${-props.margin} ${width()} ${height()}`>
      <rect x=-props.margin y=-props.margin {width(), height()} fill=offColor()>
      <For each=polygons>(polygon) =>
        <polygon points={polygon.map([x, y] => `${x},${y}`).join " "} fill=onColor() stroke="none">

export function App()
  [margin, setMargin] := createSignal<number> 1
  [qrMatrix, setQrMatrix] := createSignal<Matrix?>()
  [layers, setLayers] := createSignal<Layering?>()

  let textRef: HTMLInputElement, qualityRef: HTMLSelectElement
  function onInput(): void
    text := textRef.value
    unless text
      setQrMatrix undefined
      setLayers undefined
      return
    qr := qrcode.create text, errorCorrectionLevel: qualityRef.value as "L" | "M" | "Q" | "H"
    setQrMatrix bitMatrixToMatrix qr.modules
    setLayers layering qrMatrix()!

  let downloadRef: HTMLAnchorElement
  function download(className: string): void
    for each svg, i of document.querySelectorAll `.${className} svg`
      text := `<?xml version="1.0" encoding="utf-8"?>\n` + svg.outerHTML
      .replace /<svg/, `<svg xmlns="http://www.w3.org/2000/svg" version="1.1"`
      url := URL.createObjectURL new Blob [text], type: 'image/svg+xml'
      downloadRef.href = url
      downloadRef.download = `qr-${className}${i+1}.svg`
      downloadRef.click() // synchronous
      downloadRef.href = ''
      URL.revokeObjectURL url

  <form onSubmit={(e) => e.preventDefault()}>
    <input {onInput} placeholder="Message for QR code" style="width: 500px" ref=textRef!>
    <select {onInput} ref=qualityRef!>
      <option value="L">Low (~7%)
      <option value="M" selected>Medium (~15%)
      <option value="Q">Quartile (~25%)
      <option value="H">High (~30%)
    <label>Margin: 
      <input type="number" value=margin() min=0 step="any" onInput=
        (e) => setMargin e.currentTarget.valueAsNumber
      >
  <Show when=qrMatrix()>
    <h2>QR Code
    <DisplayMatrix matrix=qrMatrix() {margin()}>
  <Show when=layers()>
    <h2>{layers()?.levels} Layers
    <div .layers>
      <For each=[1<=..layers()?.levels ?? 0]>(level) =>
        <Show when=false>
          <DisplayMatrix matrix={layers()?.layer.map (value) => Number value <= level} color=layers()?.colorMap.get(level) {margin()}>
        <DisplayOutlines matrix={layers()?.layer.map (value) => Number value <= level} color=layers()!.colorMap.get(level)! {margin()}>
    <button onClick={(e) => download 'layers'}>Download SVGs
    <a ref=downloadRef! style="display: none">
    <Show when=false>
      <h2>{layers()?.levels} Levels
      <For each=[1<=..layers()?.levels ?? 0]>(level) =>
        <DisplayMatrix matrix={layers()?.layer.map (value) => Number value is level} {margin()}>
